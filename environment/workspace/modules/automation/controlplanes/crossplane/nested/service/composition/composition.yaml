apiVersion: apiextensions.crossplane.io/v1
kind: Composition
metadata:
  name: catalogservice.awsblueprints.io
spec:
  compositeTypeRef:
    apiVersion: awsblueprints.io/v1alpha1
    kind: XCatalogService
  patchSets:
    - name: common-fields
      patches:
        - fromFieldPath: spec.namespace
          toFieldPath: spec.forProvider.manifest.metadata.namespace
        - fromFieldPath: metadata.name
          toFieldPath: spec.forProvider.manifest.metadata.name
        - fromFieldPath: spec.resourceConfig.providerConfigName
          toFieldPath: spec.providerConfigRef.name
  resources:
    - base:
        apiVersion: kubernetes.crossplane.io/v1alpha1
        kind: Object
        spec:
          forProvider:
            manifest:
              apiVersion: apps/v1
              kind: Deployment
              metadata:
                labels:
                  app.kubernetes.io/created-by: eks-workshop
                  app.kubernetes.io/type: app
                namespace: to-be-patched
              spec:
                selector:
                  matchLabels:
                    app.kubernetes.io/name: catalog
                    app.kubernetes.io/instance: to-be-patched
                    app.kubernetes.io/component: service
                template:
                  metadata:
                    annotations:
                      prometheus.io/path: /metrics
                      prometheus.io/port: "8080"
                      prometheus.io/scrape: "true"
                    labels:
                      app.kubernetes.io/name: catalog
                      app.kubernetes.io/instance: to-be-patched
                      app.kubernetes.io/component: service
                      app.kubernetes.io/created-by: eks-workshop
                  spec:
                    serviceAccountName: to-be-patched
                    securityContext:
                      fsGroup: 1000
                    containers:
                      - name: catalog
                        env:
                          - name: DB_USER
                            valueFrom:
                              secretKeyRef:
                                name: to-be-patched
                                key: username
                          - name: DB_PASSWORD
                            valueFrom:
                              secretKeyRef:
                                name: to-be-patched
                                key: password
                          - name: DB_READ_ENDPOINT
                            valueFrom:
                              secretKeyRef:
                                name: to-be-patched
                                key: endpoint
                          - name: DB_ENDPOINT
                            valueFrom:
                              secretKeyRef:
                                name: to-be-patched
                                key: endpoint
                          - name: DB_NAME
                            value: to-be-patched
                        securityContext:
                          capabilities:
                            drop:
                            - ALL
                          readOnlyRootFilesystem: true
                          runAsNonRoot: true
                          runAsUser: 1000
                        image: "public.ecr.aws/aws-containers/retail-store-sample-catalog:0.4.0"
                        imagePullPolicy: IfNotPresent
                        ports:
                          - name: http
                            containerPort: 8080
                            protocol: TCP
                        livenessProbe:
                          httpGet:
                            path: /health
                            port: 8080
                          initialDelaySeconds: 30
                          periodSeconds: 3
                        readinessProbe:
                          httpGet:
                            path: /health
                            port: 8080
                          successThreshold: 3
                          periodSeconds: 5
                        resources:
                          limits:
                            memory: 512Mi
                          requests:
                            cpu: 250m
                            memory: 512Mi
                        volumeMounts:
                          - mountPath: /tmp
                            name: tmp-volume
                    volumes:
                      - name: tmp-volume
                        emptyDir:
                          medium: Memory
      patches:
        - type: PatchSet
          patchSetName: common-fields
        - fromFieldPath: spec.replicas
          toFieldPath: spec.forProvider.manifest.spec.replicas
        - fromFieldPath: spec.secret
          toFieldPath: spec.forProvider.manifest.spec.template.spec.containers[0].env[0].valueFrom.secretKeyRef.name
        - fromFieldPath: spec.secret
          toFieldPath: spec.forProvider.manifest.spec.template.spec.containers[0].env[1].valueFrom.secretKeyRef.name
        - fromFieldPath: spec.secret
          toFieldPath: spec.forProvider.manifest.spec.template.spec.containers[0].env[2].valueFrom.secretKeyRef.name
        - fromFieldPath: spec.secret
          toFieldPath: spec.forProvider.manifest.spec.template.spec.containers[0].env[3].valueFrom.secretKeyRef.name
        - fromFieldPath: spec.databaseName
          toFieldPath: spec.forProvider.manifest.spec.template.spec.containers[0].env[4].value
        - fromFieldPath: spec.forProvider.manifest.metadata.name
          toFieldPath: spec.forProvider.manifest.spec.selector.matchLabels[app.kubernetes.io/instance]
        - fromFieldPath: spec.forProvider.manifest.metadata.name
          toFieldPath: spec.forProvider.manifest.spec.template.metadata.labels[app.kubernetes.io/instance]
        - fromFieldPath: status.serviceAccountName
          toFieldPath: spec.forProvider.manifest.spec.template.spec.serviceAccountName
          policy:
            # By default a patch from a field path that does not exist is simply
            # skipped until it does. Use the 'Required' policy to instead block and
            # return an error when the field path does not exist.
            fromFieldPath: Required
    - base:
        apiVersion: kubernetes.crossplane.io/v1alpha1
        kind: Object
        spec:
          forProvider:
            manifest:
              apiVersion: v1
              kind: ServiceAccount
      patches:
        - type: PatchSet
          patchSetName: common-fields
        - type: ToCompositeFieldPath
          fromFieldPath: spec.forProvider.manifest.metadata.name
          toFieldPath: status.serviceAccountName
    - base:
        apiVersion: kubernetes.crossplane.io/v1alpha1
        kind: Object
        spec:
          forProvider:
            manifest:
              apiVersion: v1
              kind: Service
              metadata:
                labels:
                  app.kubernetes.io/created-by: eks-workshop
              spec:
                type: ClusterIP
                ports:
                  - port: 80
                    targetPort: http
                    protocol: TCP
                    name: http
                selector:
                  app.kubernetes.io/name: catalog
                  app.kubernetes.io/instance: to-be-patched
                  app.kubernetes.io/component: service
      patches:
        - type: PatchSet
          patchSetName: common-fields
        - fromFieldPath: spec.forProvider.manifest.metadata.name
          toFieldPath: spec.forProvider.manifest.spec.selector[app.kubernetes.io/instance]
        - type: CombineToComposite
          combine:
            # The patch will only be applied when all variables have non-zero values.
            variables:
            - fromFieldPath: spec.forProvider.manifest.metadata.name
            - fromFieldPath: spec.forProvider.manifest.metadata.namespace
            strategy: string
            string:
              fmt: "http://%s.%s"
          toFieldPath: status.serviceURL

